#version 460

layout (local_size_x = 8, local_size_y = 8) in;

layout (binding = 0) uniform sampler2D u_worldData;

layout (std430, binding = 0) restrict writeonly
buffer Positions {
    vec3 positions[];
};

layout (std430, binding = 1) restrict writeonly
buffer Normals {
    vec3 normals[];
};

layout (std430, binding = 2) restrict writeonly
buffer TexCoords {
    vec2 texCoords[];
};

layout (std430, binding = 3) restrict writeonly
buffer Indices {
    uint indices[];
};

void main() {
    uvec2 grid_size = (gl_WorkGroupSize * gl_NumWorkGroups).xy;
    uint thread_id = gl_GlobalInvocationID.y * grid_size.x + gl_GlobalInvocationID.x;

    vec2 texCoord = vec2(gl_GlobalInvocationID) / (grid_size.xy - 1);
    float height = texture(u_worldData, texCoord).r;

    vec2 texCoord_plus_d = vec2(gl_GlobalInvocationID + 1) / (grid_size.xy - 1);
    vec2 height_plus_d = {
        texture(u_worldData, vec2(texCoord_plus_d.x, texCoord.y)).x,
        texture(u_worldData, vec2(texCoord.x, texCoord_plus_d.y)).x
    };
    vec2 dheight_d = (height_plus_d - height) / (texCoord_plus_d - texCoord);

    positions[thread_id] = vec3(texCoord.x, height, texCoord.y);
    normals[thread_id] = vec3(-dheight_d.x, 1, -dheight_d.y);
    texCoords[thread_id] = texCoord;

    // write indices to EBO
    if (gl_GlobalInvocationID.x < grid_size.x - 1 && gl_GlobalInvocationID.y < grid_size.y - 1) {
        uint offset = thread_id * 6;
        indices[offset] = thread_id;
        indices[offset + 1] = thread_id + grid_size.x + 1;
        indices[offset + 2] = thread_id + 1;
        indices[offset + 3] = thread_id + grid_size.x + 1;
        indices[offset + 4] = thread_id;
        indices[offset + 5] = thread_id + grid_size.x;
    }
}
